{"version":3,"file":"effects.js","sources":["../src/models.ts","../src/effect_creator.ts","../src/utils.ts","../src/effect_decorator.ts","../src/effects_metadata.ts","../src/effects_resolver.ts","../src/actions.ts","../src/effect_notification.ts","../src/lifecycle_hooks.ts","../src/effect_sources.ts","../src/tokens.ts","../src/effects_runner.ts","../src/effects_root_module.ts","../src/effects_feature_module.ts","../src/effects_module.ts","../src/act.ts","../effects.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  resubscribeOnError?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  resubscribeOnError: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport type EffectPropertyKey<T extends Object> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Object>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T> = {\n  [key in EffectPropertyKey<T>]?: EffectConfig\n};\n","import { Observable } from 'rxjs';\nimport { Action } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `resubscribeOnError` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends Observable<OT> | ((...args: any[]) => Observable<OT>)\n>(source: () => R, config?: Partial<C>): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter(\n      propertyName =>\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n    )\n    .map(propertyName => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n","export function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n","import { compose } from '@ngrx/store';\n\nimport {\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  EffectPropertyKey,\n} from './models';\nimport { getSourceForInstance } from './utils';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\nexport function Effect(config: EffectConfig = {}) {\n  return function<T extends Object, K extends EffectPropertyKey<T>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = {\n      ...DEFAULT_EFFECT_CONFIG,\n      ...config, // Overrides any defaults if values are provided\n      propertyName,\n    };\n    addEffectMetadataEntry<T>(target, metadata);\n  };\n}\n\nexport function getEffectDecoratorMetadata<T>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effectsDecorators: EffectMetadata<T>[] = compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n\n  return effectsDecorators;\n}\n\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries<T extends Object>(\n  sourceProto: T\n): sourceProto is typeof sourceProto & {\n  constructor: typeof sourceProto.constructor & {\n    [METADATA_KEY]: EffectMetadata<T>[];\n  };\n} {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry<T extends object>(\n  sourceProto: T,\n  metadata: EffectMetadata<T>\n) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata],\n    });\n  }\n}\n\nfunction getEffectMetadataEntries<T extends object>(\n  sourceProto: T\n): EffectMetadata<T>[] {\n  return hasMetadataEntries(sourceProto)\n    ? sourceProto.constructor[METADATA_KEY]\n    : [];\n}\n","import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\nimport { getEffectDecoratorMetadata } from './effect_decorator';\n\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, resubscribeOnError }\n    ) => {\n      acc[propertyName] = { dispatch, resubscribeOnError };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T>(instance: T): EffectMetadata<T>[] {\n  const effects: Array<(instance: T) => EffectMetadata<T>[]> = [\n    getEffectDecoratorMetadata,\n    getCreateEffectMetadata,\n  ];\n\n  return effects.reduce<EffectMetadata<T>[]>(\n    (sources, source) => sources.concat(source(instance)),\n    []\n  );\n}\n","import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize, catchError } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  errorHandler?: ErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      resubscribeOnError,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const resubscribable$ = resubscribeOnError\n        ? resubscribeInCaseOfError(observable$, errorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return resubscribable$.pipe(ignoreElements());\n      }\n\n      const materialized$ = resubscribable$.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n\nfunction resubscribeInCaseOfError<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler?: ErrorHandler\n): Observable<T> {\n  return observable$.pipe(\n    catchError(error => {\n      if (errorHandler) errorHandler.handleError(error);\n      // Return observable that produces this particular effect\n      return resubscribeInCaseOfError(observable$, errorHandler);\n    })\n  );\n}\n","import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable()\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some(typeOrActionCreator => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable } from 'rxjs';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n","import { ErrorHandler, Injectable } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Notification, Observable, Subject } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  OnRunEffects,\n  onInitEffects,\n} from './lifecycle_hooks';\nimport { getSourceForInstance } from './utils';\n\n@Injectable()\nexport class EffectSources extends Subject<any> {\n  constructor(private errorHandler: ErrorHandler, private store: Store<any>) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n\n    if (\n      onInitEffects in effectSourceInstance &&\n      typeof effectSourceInstance[onInitEffects] === 'function'\n    ) {\n      this.store.dispatch(effectSourceInstance[onInitEffects]());\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap(source$ => source$.pipe(groupBy(effectsInstance))),\n      mergeMap(source$ =>\n        source$.pipe(\n          exhaustMap(resolveEffectSource(this.errorHandler)),\n          map(output => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is Notification<Action> =>\n              notification.kind === 'N'\n          ),\n          dematerialize()\n        )\n      )\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (\n    onIdentifyEffectsKey in sourceInstance &&\n    typeof sourceInstance[onIdentifyEffectsKey] === 'function'\n  ) {\n    return sourceInstance[onIdentifyEffectsKey]();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return sourceInstance => {\n    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler);\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n\nfunction isOnRunEffects(\n  sourceInstance: Partial<OnRunEffects>\n): sourceInstance is OnRunEffects {\n  const source = getSourceForInstance(sourceInstance);\n\n  return (\n    onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function'\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable()\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport {\n  createAction,\n  StoreModule,\n  Store,\n  StoreRootModule,\n  StoreFeatureModule,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: any\n  ) {\n    runner.start();\n\n    rootEffects.forEach(effectSourceInstance =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach(group =>\n      group.forEach(effectSourceInstance =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import {\n  NgModule,\n  ModuleWithProviders,\n  Type,\n  Optional,\n  SkipSelf,\n} from '@angular/core';\nimport { EffectSources } from './effect_sources';\nimport { Actions } from './actions';\nimport { ROOT_EFFECTS, FEATURE_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[]\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          deps: featureEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[]\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [[EffectsRunner, new Optional(), new SkipSelf()]],\n        },\n        EffectsRunner,\n        EffectSources,\n        Actions,\n        rootEffects,\n        {\n          provide: ROOT_EFFECTS,\n          deps: rootEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n}\n\nexport function createSourceInstances(...instances: any[]) {\n  return instances;\n}\n\nexport function _provideForRootGuard(runner: EffectsRunner): any {\n  if (runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return source =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map(\n                    (notification): Notification<ResultAction> | undefined => {\n                      switch (notification.kind) {\n                        case 'E':\n                          errored = true;\n                          return new Notification(\n                            // TODO: remove any in RxJS 6.5\n                            'N' as any,\n                            error(notification.error, input)\n                          );\n                        case 'C':\n                          completed = true;\n                          return complete\n                            ? new Notification(\n                                // TODO: remove any in RxJS 6.5\n                                'N' as any,\n                                complete(projectedCount, input)\n                              )\n                            : undefined;\n                        default:\n                          ++projectedCount;\n                          return notification;\n                      }\n                    }\n                  ),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {getSourceMetadata as Éµngrx_modules_effects_effects_a} from './src/effects_metadata';\nexport {_provideForRootGuard as Éµngrx_modules_effects_effects_c,createSourceInstances as Éµngrx_modules_effects_effects_b} from './src/effects_module';\nexport {EffectsRunner as Éµngrx_modules_effects_effects_g} from './src/effects_runner';\nexport {FEATURE_EFFECTS as Éµngrx_modules_effects_effects_f,ROOT_EFFECTS as Éµngrx_modules_effects_effects_e,_ROOT_EFFECTS_GUARD as Éµngrx_modules_effects_effects_d} from './src/tokens';"]}